<!DOCTYPE html>
<html lang="ja" xmlns:th="http://www.thymeleaf.org">
<head>
  <meta charset="UTF-8">
  <title th:text="${playerName}">｜MoveAsYou</title>
  <style>
      .token-form {
          margin: 20px;
          padding: 20px;
      }

      .hidden {
          display: none;
      }
      
      .green {
          background-color: limegreen;
          color: darkred;
      }
      .blue {
          background-color: darkblue;
          color: gold;
      }
      
      body>header p {
          font-style: italic;
      }
  </style>
  <link rel="stylesheet" href="/static/skin3d.css">
  <style th:inline="css">
      #minecraft-skin {
          --skin-image: url([[${playerSkin}]]);
      }
  </style>
  <script>
    let FPS = 60; //temp-value. update with function
    
    function getCurrentFPS(){
        let frameCount = 0;
        let startTime = performance.now();
        const fpsDisplay = document.getElementById('fpsDisplay');
        
        /** 1秒のフレーム更新回数(=FPS)を計測＆出力 */
        function measureFrame(){
            const now = performance.now();
            frameCount++;
            if (startTime < (now - 1000)){
                //1秒経過していたら
                FPS = frameCount;
                //ログ&出力
                console.log(`[${new Date().toISOString()}]FPS：${FPS}`);
                fpsDisplay.innerText = `${FPS}`;
                return; //FPS計測終了
            }

            //1フレーム後への実行リクエスト
            requestAnimationFrame(measureFrame); 
        }
        
        measureFrame(); //計測開始
    }

    setInterval(()=>{
        try{ getCurrentFPS(); } catch(e){console.error('FPS計測エラー',e)}
    }, 30 * 1000); //30秒毎計測
    
  </script>
</head>
<body th:class="${bgColor}">
  <header>
    <h1 th:text="${playerName}"></h1>
    <p><span id="fpsDisplay">60</span>FPS</p><script>getCurrentFPS(); //初回計測指示</script>
  </header>
  <main>
    <section th:hidden="${isOnline}">
      <p>現在サーバに居ないので表示できません</p>
    </section>
    <section th:hidden="${!isOnline}">
      <p>トークン発行コマンド（クリックでコピー）</p>
      <dl>
        <dt>使い捨てトークン</dt><dd><code>/moveasyou token</code></dd>
        <dt>配信向けトークン</dt><dd><code>/moveasyou token stream</code></dd>
        <dt>管理者用トークン</dt><dd><code>/moveasyou token admin</code></dd>
        <script>
            const checkedEle = document.createElement('span');
            checkedEle.innerText = '✓copy✓';
            document.querySelectorAll('code').forEach((ele)=>{
                ele.addEventListener('click',(e)=>{
                    const bodyVal = e.target.innerHTML;
                    navigator.clipboard.writeText(bodyVal).then(() => {
                        e.target.appendChild(checkedEle);
                        setTimeout(() => {
                            e.target.removeChild(checkedEle);
                        }, 3000);
                    }).catch(err => {
                        console.error('Failed to copy command:', err);
                    });
                });
            });
        </script>
      </dl>
      <div class="token-form" id="tokenForm">
        <label>サーバーで発行されたトークン：<input type="text" id="tokenInput" placeholder="apple-gold-ingot"></label>
        <button onclick="connectToServer()">接続</button>
      </div>
      <div id="gameArea" class="hidden">
        <p>接続済み</p>
        <button onclick="disconnect()">切断</button>
      </div>
    </section>
    <figure id="bgFig" th:class="${bgColor}">
      <div id="minecraft-skin" th:class="${skinModel}">
        <div class="head cube" id="mc-head">
          <div class="top"></div>
          <div class="bottom"></div>
          <div class="left"></div>
          <div class="right"></div>
          <div class="front"></div>
          <div class="back"></div>
          <div class="accessories">
            <div class="cube">
              <div class="top"></div>
              <div class="bottom"></div>
              <div class="left"></div>
              <div class="right"></div>
              <div class="front"></div>
              <div class="back"></div>
            </div>
          </div>
        </div>
        <div class="body cube">
          <div class="top"></div>
          <div class="bottom"></div>
          <div class="left"></div>
          <div class="right"></div>
          <div class="front"></div>
          <div class="back"></div>
        </div>
        <div class="arm right cube">
          <div class="top"></div>
          <div class="bottom"></div>
          <div class="left"></div>
          <div class="right"></div>
          <div class="front"></div>
          <div class="back"></div>
        </div>
        <div class="arm left cube">
          <div class="top"></div>
          <div class="bottom"></div>
          <div class="left"></div>
          <div class="right"></div>
          <div class="front"></div>
          <div class="back"></div>
        </div>
        <div class="legs left cube">
          <div class="top"></div>
          <div class="bottom"></div>
          <div class="left"></div>
          <div class="right"></div>
          <div class="front"></div>
          <div class="back"></div>
        </div>
        <div class="legs right cube">
          <div class="top"></div>
          <div class="bottom"></div>
          <div class="left"></div>
          <div class="right"></div>
          <div class="front"></div>
          <div class="back"></div>
        </div>
      </div>
    </figure>

    <script th:inline="javascript">
        const DOMAIN = window.location.hostname;
        const SOCKET_PORT = /*[[${socketPort}]]*/ '';
        const PLAYER_NAME = /*[[${playerName}]]*/ '';
        
        let socket;

        function connectToServer() {
            const token = document.getElementById('tokenInput').value;
            if (!token) {
                alert('トークンを入力してください');
                return;
            }

            fetch('/auth/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    token: token,
                    playerName: PLAYER_NAME
                })
            })
                .then(response => {
                    if (response.status === 200) {
                        connectWebSocket(token);
                    } else if (response.status === 429) {
                        alert('接続数が制限を超えています。しばらく待ってから再度お試しください。');
                        connectWebSocket = undefined;
                        sendSocketMessage = undefined;
                    } else if (response.status === 400) {
                        alert('入力したトークンが有効か確認してください');
                    } else {
                        alert('不明なエラー');
                        console.error('Authentication failed with status:', response.status);
                    }
                })
                .catch(error => {
                    console.error('Authentication error:', error);
                });
        }

        function connectWebSocket(token) {
            socket = new WebSocket('ws://' + DOMAIN + ':' + SOCKET_PORT + '/socket/player/'+ PLAYER_NAME);

            // 接続時にトークンをヘッダーに設定
            socket.onopen = function() {
                socket.send('Token:' + token);
                document.getElementById('tokenForm').classList.add('hidden');
                document.getElementById('gameArea').classList.remove('hidden');
                console.info('Socket通信を開始しました');
            };

            socket.onmessage = function(event) {
                const data = JSON.parse(event.data);
                if(data.playerName){
                    motionEvent(data);
                }
                if(data.animationType){
                    animationEvent(data);
                }
            };

            socket.onclose = function(event) {
                if (event.code === 4000) {
                    alert('Tokenが正しくない可能性があります');
                }
                if (event.code === 4001) {
                    alert('プレイヤーがオフラインになった可能性があります');
                }
                if(event.code === 4029){
                    alert('レート制限に抵触しています');
                    sendSocketMessage = undefined;
                    socket = null;
                    connectWebSocket = undefined;
                }
                console.warn('Socket通信が切断されました');
                document.getElementById('gameArea').classList.add('hidden');
                document.getElementById('tokenForm').classList.remove('hidden');
            };

            socket.onerror = function(error) {
                console.error('Socketエラー: ' + error);
            };
        }

        function sendSocketMessage(message) {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(message);
                console.log('送信: ' + message);
                document.getElementById('messageInput').value = '';
            } else {
                alert('サーバーに接続されていません');
            }
        }

        function disconnect(){
            if (socket){
                socket.close(1000); //1000:NormalClose
            }
            socket = null;
        }
        
        /** 1tick毎の動作状況socket通信に対応 */
        function motionEvent(data){
            if (lastPitch === data.pitch){ return; }
            console.log(data.pitch + "," + data.itemInHand);
            lastPitch = data.pitch;
            const viewPitch = data.pitch * 2 / 3;
            const radPitch = viewPitch * Math.PI / 180;
            const fixY = -40 * (1 - Math.cos(radPitch));
            const fixZ = 40 * Math.sin(radPitch);
            skinViewHead.style.transform = `rotateX(${-1 * viewPitch}deg) translate3d(0px,${fixY}px,${fixZ}px)`;
        }
        let lastPitch = 0;
        
        /** Animationの通知socket通信に対応 */
        function animationEvent(data){
            console.log(data.animationType);
        }
        
        const skinView = document.getElementById('minecraft-skin');
        const skinViewHead = document.getElementById('mc-head');
        let isDragging = false;
        let startX, startY;
        let currentRotationX = 0, currentRotationY = 0;
        const ROTATION_SCALE = 0.75;
        skinView.addEventListener('mousedown', (e)=>{
           isDragging = true;
           startX = e.clientX; startY = e.clientY;
        });
        window.addEventListener('mousemove', (e)=>{
            if (isDragging == false){ return; }
            const dX = e.clientX - startX;
            const dY = e.clientY - startY;
            const rotateX = currentRotationX - dY * ROTATION_SCALE;
            const rotateY = currentRotationY + dX * ROTATION_SCALE;
            console.log(rotateX + "," + rotateY);
            skinView.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
            currentRotationX = rotateX; currentRotationY = rotateY;
            startX = e.clientX; startY = e.clientY;
        })
        window.addEventListener('mouseup', ()=>{ isDragging = false; });
    </script>
  </main>
</body>
</html>